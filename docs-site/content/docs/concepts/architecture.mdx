---
title: Architecture Overview
description: High-level overview of how HORUS works
order: 25
---

# Architecture Overview

This page explains how HORUS is organized at a high level. You don't need to understand these details to use HORUS - this is for those curious about how the framework works.

## The Big Picture

HORUS has three main layers:

```
┌─────────────────────────────────────────────────────────────┐
│                     Your Application                         │
│  (Nodes you write using the node! macro or Node trait)      │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    HORUS Framework                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │
│  │  Scheduler  │  │    Hub      │  │  Standard   │         │
│  │ (runs your  │  │ (connects   │  │  Library    │         │
│  │   nodes)    │  │   nodes)    │  │  (sensors,  │         │
│  │             │  │             │  │   motors)   │         │
│  └─────────────┘  └─────────────┘  └─────────────┘         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                   Shared Memory                              │
│  (Fast communication between your nodes)                    │
└─────────────────────────────────────────────────────────────┘
```

## Core Components

### 1. Scheduler - Runs Your Nodes

The Scheduler is like a conductor - it calls each node's `tick()` method in priority order, over and over.

```rust
// The scheduler runs your nodes automatically
let mut scheduler = Scheduler::new();
scheduler.add(Box::new(my_node), 5, Some(true));
scheduler.run()?;  // Runs until Ctrl+C
```

**Key points:**
- Lower priority number = runs first (0 = highest priority)
- Default tick rate is ~60 Hz (can be configured)
- Handles graceful shutdown (Ctrl+C)

### 2. Hub - Connects Your Nodes

Hub is how nodes talk to each other. Think of it like a message board - one node posts a message, another reads it.

```rust
// Publisher node
let velocity_pub: Hub<f32> = Hub::new("velocity")?;
velocity_pub.send(1.5, &mut ctx)?;

// Subscriber node (different node, same topic name)
let velocity_sub: Hub<f32> = Hub::new("velocity")?;
if let Some(vel) = velocity_sub.recv(&mut ctx) {
    // Got the velocity!
}
```

**Key points:**
- Same topic name = same channel
- Multiple publishers and subscribers supported
- Sub-microsecond latency (~400ns)

### 3. Standard Library - Ready-Made Components

The `horus_library` provides pre-built nodes and message types so you don't start from scratch.

**Message Types:**
- `CmdVel` - Velocity commands (linear + angular)
- `Odometry` - Position and orientation
- `LaserScan` - LIDAR data
- `IMU` - Accelerometer + gyroscope data

**Built-in Nodes:**
- Motor drivers (DC, stepper, servo)
- Sensor interfaces (camera, LIDAR, IMU)
- Control algorithms (PID, path planning)

---

## How Data Flows

Here's what happens when your robot runs:

```
1. Sensor Node reads hardware
         │
         ▼
2. Publishes to Hub ("sensor_data")
         │
         ▼
3. Control Node subscribes, processes data
         │
         ▼
4. Publishes command ("motor_cmd")
         │
         ▼
5. Motor Node subscribes, moves robot
```

**All of this happens in microseconds**, not milliseconds. That's why HORUS is fast enough for real-time control.

---

## Why Shared Memory?

HORUS uses **shared memory** instead of network sockets for communication. This is why it's so fast:

| Method | Typical Latency |
|--------|-----------------|
| Network socket | 50-100 μs |
| **HORUS shared memory** | **0.4 μs** |

**100x faster** than traditional approaches.

The shared memory files are stored in:
- Linux: `/dev/shm/horus/`
- macOS: `/tmp/horus/`
- Windows: `%TEMP%\horus\`

You don't need to manage these files - HORUS handles them automatically.

---

## Project Structure

When you create a HORUS project, you typically have:

```
my_robot/
├── main.rs          # Your application code
├── horus.yaml       # Project configuration
└── .horus/          # Auto-generated build files (ignore this)
```

Run with:
```bash
horus run
```

That's it! HORUS handles compilation and execution.

---

## What You DON'T Need to Know

As a user, you don't need to understand:
- Internal crate organization
- Shared memory implementation details
- Lock-free algorithm internals
- Memory alignment and cache optimization

These are handled by the framework. Focus on your robot logic!

---

## Next Steps

- **[Quick Start](/getting-started/quick-start)** - Build your first HORUS application
- **[Nodes](/concepts/core-concepts-nodes)** - Understand the Node lifecycle
- **[Hub](/concepts/core-concepts-hub)** - Learn about pub/sub communication
- **[node! Macro](/concepts/node-macro)** - Write nodes with minimal boilerplate

---

> **For Contributors:** If you're interested in HORUS internals for contributing or extending the framework, see the [Internal Architecture Guide](/development/internal-architecture).
